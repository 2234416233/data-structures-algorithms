# 表

find、insert、remove

## 实现方式

### 简单数组实现

时间复杂度：

- find，常数时间
- insert
    1. 如果发生在数组末尾，没有元素移动，花费常数时间
    2. 如果发生在数组起始位置，需要将整个数组后移，将花费O(N)<br>
平均来看，插入需要移动一半的元素，需要线性时间
- remove，与insert操作一样，平均来看，需要移动一半的元素，需要线性时间

存在很多情况，仅仅在表的末尾进行insert，然后进行find，这是，数组是表的一种
恰当实现。

### 链表实现

时间复杂度：

- find，从表的第一个节点开始，然后通过后继的next链遍历，直到找到相应索引，
返回元素。这显然需要线性时间。
- insert，需要进行两次引用的调整，将要插入位置的前驱元的next指向要插入的新元素；
将新元素的next指向后继元素。
    1. 如果发生在表的第一项，直接改引用，花费常数时间
    2. 如果发生在表的最后，如果我们拥有对最后节点的链，那么也能花费常数时间
- remove，与insert类似，
    1. 对于第一项花费常数时间。
    2. 对于最后一项，如果我们拥有对最后节点的链，末尾节点又拥有指向它前驱元的链，
    这样，就能通过将前驱元的next指向null，并改变我们持有的对最后节点的链指向新的
    末尾元素就行了。这样也能花费常数时间。
    
所以，对于链表的每个节点，我们让它既有指向后继元的链，也有指向前驱元的链。
我们称之为**双链表**。
同时，我们还应有指向第一项与末尾项的链。

## 迭代器

### 增强的for循环

对于实现了Iterable接口的对象，如果对此施加一个增强的for循环，编译器会对其进行重写：

```
for(T t:coll)
    System.out.println(t);
```

重写成：

```
Iterator<T> itr=coll.iterator();

while(itr.hasNext()){
    T t=itr.next();
    System.out.println(t);
}
```

### remove方法

比起使用Collection的remove方法，我们更喜欢使用迭代器的remove方法，它的优点有：

1. 当直接使用Iterator（而不是通过增强的for循环间接调用使），有一个基本法则是：如果
对正在迭代的集合进行结构上的改变（add、remove以及clear方法等）时，迭代器将会不再合法
（并且在其后使用的时候会抛出ConcurrentModificationException异常）。幸运的是，迭代器
提供了自己的remove方法，调用这个remove方法的时候，迭代器仍然是合法的。
2. Collection的remove方法必须首先找出要被删除的项。而迭代器在remove之前，就已经来到了
要被删除元素的位置，这具有更高的效率。